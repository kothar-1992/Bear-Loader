HWID (Hardware ID) â€” Implementation and Testing Guide

Overview
- The project uses a stable HWID generated by a pluggable HWIDProvider interface.
- Default Android implementation (AndroidHWIDProvider) computes an MD5 fingerprint of several Build properties and returns
  the uppercase hex string. This value is persisted through SecurePreferences as KEY_HWID.

Persistence & Encryption
- HWID is stored via `SecurePreferences.storeHWID()` under the key `device_hwid`.
- SecurePreferences uses the KeystoreProvider to encrypt data with AES/GCM when Android Keystore is available. If encryption
  initialization fails, it falls back to unencrypted SharedPreferences (prefixed fallback name).
- The HWID is Base64-wrapped after encryption when encrypted.

Testing Guidance
- Unit tests that don't require Android APIs can mock `HWIDProvider` to return deterministic values.
  Example (Mockito-kotlin):
  val hwidProvider = mock<HWIDProvider>()
  whenever(hwidProvider.getHWID()).thenReturn("TEST-HWID-123")

- For JVM tests that need Android Context (to verify persistence), use Robolectric and the provided `AndroidHWIDProviderTest`.

- Avoid mocking final Android classes; prefer the provider interfaces (HWIDProvider, KeystoreProvider) which are easy to mock.

When to use what
- Pure unit tests: mock HWIDProvider and KeystoreProvider to avoid Android dependencies.
- Integration tests (Robolectric): use AndroidHWIDProvider with Robolectric runner to exercise the fingerprint algorithm and
  persistence through SecurePreferences.

Notes
- The MD5-based fingerprint algorithm is a deterministic approach over device Build properties; on some devices ANDROID_ID may
  be available and used as a fallback if provider fails.
- If you change storage formats, add a migration path in `PreferencesMigration.kt` (not present by default) and keep an eye on
  backward compatibility for stored tokens and HWID values.
