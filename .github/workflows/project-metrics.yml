name: Project Metrics

on:
  schedule:
    - cron: '0 6 * * *' # Daily at 06:00 UTC
  workflow_dispatch:

jobs:
  generate-metrics:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
      issues: read
      pull-requests: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Gather metrics and write report
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const sinceDays = 30;
            const since = new Date(Date.now() - sinceDays * 24 * 60 * 60 * 1000).toISOString();

            // Helper: list PRs updated since
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', per_page: 100 });
            const openPrs = prs.data;

            const openPrAgeBuckets = { '<=7':0, '<=14':0, '<=30':0, '>30':0 };
            const now = Date.now();
            for (const pr of openPrs) {
              const ageDays = Math.floor((now - new Date(pr.created_at).getTime()) / (24*60*60*1000));
              if (ageDays <=7) openPrAgeBuckets['<=7']++;
              else if (ageDays <=14) openPrAgeBuckets['<=14']++;
              else if (ageDays <=30) openPrAgeBuckets['<=30']++;
              else openPrAgeBuckets['>30']++;
            }

            // Mean time to merge over merged PRs in the last 30 days
            const mergedPrs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'closed', per_page: 100 });
            const recentMerged = mergedPrs.filter(p => p.merged_at && new Date(p.merged_at) >= new Date(since));
            let totalMergeMs = 0;
            const mergeDurations = [];
            for (const p of recentMerged) totalMergeMs += (new Date(p.merged_at) - new Date(p.created_at));
            const meanTimeToMergeDays = recentMerged.length ? (totalMergeMs / recentMerged.length) / (24*60*60*1000) : 0;
            for (const p of recentMerged) mergeDurations.push((new Date(p.merged_at) - new Date(p.created_at)) / (24*60*60*1000));
            // median
            let medianTimeToMergeDays = 0;
            if (mergeDurations.length) {
              mergeDurations.sort((a,b) => a-b);
              const mid = Math.floor(mergeDurations.length/2);
              medianTimeToMergeDays = (mergeDurations.length % 2 === 0) ? ((mergeDurations[mid-1]+mergeDurations[mid])/2) : mergeDurations[mid];
            }

            // Average review comments per merged PR
            const totalReviewComments = recentMerged.reduce((acc,p) => acc + (p.review_comments || 0), 0);
            const avgReviewComments = recentMerged.length ? (totalReviewComments / recentMerged.length) : 0;

            // CI pass rate: check workflow runs in last 30 days
            const runs = await github.paginate(github.rest.actions.listWorkflowRunsForRepo, { owner, repo, per_page: 100 });
            const recentRuns = runs.filter(r => new Date(r.created_at) >= new Date(since));
            const succeeded = recentRuns.filter(r => r.conclusion === 'success').length;
            const passRate = recentRuns.length ? Math.round((succeeded / recentRuns.length) * 100) : 0;

            // Open issues by age
            const issuesRes = await github.paginate(github.rest.issues.listForRepo, { owner, repo, state: 'open', per_page: 100 });
            const issues = issuesRes.filter(i => !i.pull_request);
            const issueAgeBuckets = { '<=7':0, '<=14':0, '<=30':0, '>30':0 };
            for (const issue of issues) {
              const ageDays = Math.floor((now - new Date(issue.created_at).getTime()) / (24*60*60*1000));
              if (ageDays <=7) issueAgeBuckets['<=7']++;
              else if (ageDays <=14) issueAgeBuckets['<=14']++;
              else if (ageDays <=30) issueAgeBuckets['<=30']++;
              else issueAgeBuckets['>30']++;
            }

            // Stale issues > 60 days
            const staleThreshold = 60;
            const staleIssues = issues.filter(i => Math.floor((now - new Date(i.created_at).getTime()) / (24*60*60*1000)) > staleThreshold).length;

            // Build markdown
            const md = [];
            md.push('# Project Metrics');
            md.push('Generated: ' + new Date().toISOString());
            md.push('');
            md.push('## Pull Requests');
            md.push(`Open PRs: ${openPrs.length}`);
            md.push('');
            md.push('Open PRs by age:');
            md.push(`- <= 7 days: ${openPrAgeBuckets['<=7']}`);
            md.push(`- <= 14 days: ${openPrAgeBuckets['<=14']}`);
            md.push(`- <= 30 days: ${openPrAgeBuckets['<=30']}`);
            md.push(`- > 30 days: ${openPrAgeBuckets['>30']}`);
            md.push('');
            md.push('## Merge Metrics');
            md.push(`Mean time to merge (last ${sinceDays} days): ${meanTimeToMergeDays.toFixed(2)} days`);
            md.push(`Median time to merge (last ${sinceDays} days): ${medianTimeToMergeDays.toFixed(2)} days`);
            md.push(`Average review comments (merged PRs): ${avgReviewComments.toFixed(2)}`);
            md.push('');
            md.push('## CI Metrics');
            md.push(`Workflow runs (last ${sinceDays} days): ${recentRuns.length}`);
            md.push(`Pass rate: ${passRate}%`);
            md.push('');
            md.push('## Issues');
            md.push(`Open issues: ${issues.length}`);
            md.push('Open issues by age:');
            md.push(`- <= 7 days: ${issueAgeBuckets['<=7']}`);
            md.push(`- <= 14 days: ${issueAgeBuckets['<=14']}`);
            md.push(`- <= 30 days: ${issueAgeBuckets['<=30']}`);
            md.push(`- > 30 days: ${issueAgeBuckets['>30']}`);
            md.push('');
            md.push(`Stale issues (> ${staleThreshold} days): ${staleIssues}`);

            const content = md.join('\n');

            // Write file to reports/project-metrics.md (create folder if needed)
            const path = 'reports/project-metrics.md';
            const enc = Buffer.from(content).toString('base64');

            try {
              // Check if file exists
              const existing = await github.rest.repos.getContent({ owner, repo, path });
              // Update
              await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path, message: 'chore(reports): update project metrics', content: enc, sha: existing.data.sha
              });
            } catch (err) {
              // Create new
              await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path, message: 'chore(reports): add project metrics', content: enc
              });
            }

            core.info('Project metrics generated and committed to ' + path);

            // Also update README: replace between markers if present, else append
            try {
              const readmePath = 'README.md';
              let readme;
              try { readme = await github.rest.repos.getContent({ owner, repo, path: readmePath }); } catch(e) { readme = null; }
              let readmeText = '';
              if (readme && readme.data && readme.data.content) {
                readmeText = Buffer.from(readme.data.content, 'base64').toString('utf8');
              }

              const startMarker = '<!-- PROJECT_METRICS_START -->';
              const endMarker = '<!-- PROJECT_METRICS_END -->';
              const newSection = `\n${startMarker}\n${content}\n${endMarker}\n`;

              let updatedReadme = readmeText;
              if (readmeText.includes(startMarker) && readmeText.includes(endMarker)) {
                const before = readmeText.split(startMarker)[0];
                const after = readmeText.split(endMarker).slice(1).join(endMarker);
                updatedReadme = before + newSection + after;
              } else {
                // Append
                updatedReadme = readmeText + '\n' + newSection;
              }

              const encReadme = Buffer.from(updatedReadme).toString('base64');
              if (readme && readme.data && readme.data.sha) {
                await github.rest.repos.createOrUpdateFileContents({ owner, repo, path: readmePath, message: 'chore(reports): update README project metrics', content: encReadme, sha: readme.data.sha });
              } else {
                await github.rest.repos.createOrUpdateFileContents({ owner, repo, path: readmePath, message: 'chore(reports): add project metrics to README', content: encReadme });
              }

              core.info('README updated with latest project metrics');
            } catch (e) {
              core.warning('Failed to update README with metrics: ' + e.message);
            }

      - name: Upload report artifact
        uses: actions/upload-artifact@v4
        with:
          name: project-metrics
          path: reports/project-metrics.md
